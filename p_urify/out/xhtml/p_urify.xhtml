<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>p:urify</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.2"/></head><body><div xml:lang="en" class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="d5e1"/>p:urify</h2></div></div><hr/></div><p><code class="code">p:urify()</code> is a function that attempts to transform file system paths into file URIs. If a URI is already
    given as an argument, it should pass it unchanged, apart from character escaping and slash contractions that are permitted
    for (presumptive) file URIs.</p><p>The function performs an operation on strings; it does not try to determine the existence of a file or directory, it
    does not follow symbolic links, etc. The only external information that is used (if available) is the operating system name,
    the current working directory, and the file path separator character.</p><p>The function aims at supporting Unix-like (for example, Linux, Solaris, Mac OS X) and Windows file system paths.
    Operating systems with other filesystem path addressing schemes (for example, VMS or Mac OS) need not be supported.</p><code class="methodsynopsis"><span class="type">xs:string </span><span class="methodname">p:urify</span>(<span class="methodparam"><span class="type">xs:string </span><span class="parameter">filepath</span></span>,<br/>                  <span class="methodparam"><span class="type">xs:string? </span><span class="parameter">basedir</span></span>);</code><p>Each argument may be an operating system path, including Windows UNC paths, or a URI. Whether and how each argument
    needs to be transformed in order to become a URI depends on a classification based on regular expression matching (see
    below). The function will not guarantee that an argument identified as a URI is a <span class="emphasis"><em>correct</em></span> URI.</p><p>Unless stated otherwise, all regular expression matching in implementing this function must be carried out
    case-insensitively.</p><p>If the <code class="code">$basedir</code> argument is omitted or is the empty sequence, the current working directory (see below)
    will be used. The <code class="code">$basedir</code> argument or the current working directory will only be considered if the
      <code class="code">$filepath</code> is determined to be relative.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="file:/C:/Program%20Files/Oxygen%20XML%20Editor%2020/frameworks/docbook/css/img/note.png"/></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Sometimes file names are created in an encoding that does not match the system’s locale. This function does not aim at
      solving these issues. Implementations should not try to correct apparent errors that originate from garbled encodings
      since they will probably not be able to produce file URIs that address the corresponding files correctly.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e25"/>Access to the Environment</h3></div></div></div><p>The function needs access to the following information that the implementation would return for the
        <code class="code">p:os-info</code> step.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">file-separator (<code class="code">xs:string</code>)</span></dt><dd><p>The path separator, typically '/' on Unix and '\' on Windows. If none can be determined, '/' will be assumed. </p><p>The forward slash is a valid path separator for the <code class="code">filepath</code> argument even when the system’s
              <code class="code">file-separator</code> is '\'.</p></dd><dt><span class="term">os-name (<code class="code">xs:string?</code>)</span></dt><dd><p>The name of the operating system, for example 'Mac OS X'.</p></dd><dt><span class="term">cwd (<code class="code">xs:string?</code>)</span></dt><dd><p>The current working directory, that is, the directory from which the processor was invoked.</p><p>It may not be available if the pipeline or processor was not invoked from a working directory.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e49"/>Operating System Path Syntax</h3></div></div></div><p>The <em class="firstterm">operating system path syntax</em> is said to be of type “Windows” if at least one of the
      following conditions is satisfied: <code class="code">os-name</code> starts with 'Windows' or <code class="code">file-separator</code>
      is '\'.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e55"/>Classification of the arguments</h3></div></div></div><p>After finding out which operating system path syntax to expect on the current platform, the function determines the
      types of its arguments, starting with the <code class="code">$filepath</code> argument. The <code class="code">$basedir</code> argument (or
        <code class="code">cwd</code>) need only be normalized if <code class="code">$filepath</code> is determined to be relative.</p><p>Each argument is supposed to be either a file system path or already a URI. The arguments (including <code class="code">cwd</code>)
      need not be of the same type; one can be an OS path and the other one a URI.</p><p>The distinction between file system paths and URIs is too coarse-grained though for this function’s string
      manipulation rules. </p><p>The first of the following conditions that is met will determine the argument’s detailed type:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If the argument matches the regular expression <code class="code">^[a-z]:[\\/]+</code> and if the OS path syntax is of
          type “Windows”, it is determined to be an absolute Windows path with a drive letter.</p><p>If the argument matches the regular expression <code class="code">^[a-z]:[^\\/]</code> and if the OS path
          syntax is of type “Windows”, a dynamic error is thrown because relative paths with a drive letter are not 
          supported by this function.</p></li><li class="listitem"><p>If the argument starts with two backslashes, followed by a string that may serve as a host name,
          followed by a forward or backward slash, and if the OS path syntax type is “Windows”, it is determined to be a UNC
          path.</p><p>For simplification purposes, an approximate regular expression of <code class="code">[a-z0-9][-.a-z0-9]*</code> may be used to
          match a possible host name part. An implementation is free to use a more accurate regular expression.</p><p>This regular expression will also match IPv6 addresses that are escaped for UNC paths according to
          https://blogs.msdn.microsoft.com/oldnewthing/20100915-00/?p=12863/<em><span class="remark"> (move into bibliography section)</span></em>.</p></li><li class="listitem"><p>If the argument matches the regular expression <code class="code">^file:(/|/{3,})?[a-z]:/+</code> and if the OS path
          syntax is of type “Windows”, it is determined to be the file URI of an absolute Windows path with a drive
          letter.</p><p>If the argument matches the regular expression <code class="code">^file:(/|/{3,})?[a-z]:[^/]</code> and if the OS path
          syntax is of type “Windows”, a dynamic error is thrown because relative paths with a drive letter are not 
          supported.</p></li><li class="listitem"><p>If the argument matches the regular expression <code class="code">^file:(//|/{4,})[a-z\d][-.a-z\d]*/+</code> (possibly
          with a more accurate regular expression for the hostname part, see the “UNC path” type above) and if the OS path
          syntax is of type “Windows”, it is determined to be the file URI of a Windows UNC path.</p></li><li class="listitem"><p>If the argument matches the regular expression <code class="code">^file:[^/]</code>, it is determined to be a
          relative file URI.</p></li><li class="listitem"><p>If the argument matches the regular expression <code class="code">^file:/+</code>, it is determined to be an
          absolute file URI.</p></li><li class="listitem"><p>If the argument matches the regular expression <code class="code">^/+</code>, it is determined to be an absolute 
          OS path. Although this represents only non-Windows OS paths, the normalization that is applied to these
        paths by this function is the same even if the OS type is determined to be “Windows”.</p></li><li class="listitem"><p>If the argument matches <code class="code">^[a-z][-+.0-9a-z]*:</code> (a URI scheme as defined in RFC 3986, followed
          by a colon), it is determined as a non-file URI.</p><p>An implementation may perform more thorough checks against the syntax specification of RFC 3986 and raise
          a warning if the URI is non-conforming.</p></li></ul></div><p>If the argument is determined to be a file URI, the argument will further be classified as escapable or non-escapable.
        <span class="termdef">[Definition: A file URI is <em class="firstterm">escapable</em> if it contains other characters than those that match the
        regular expression <code class="code">-._~[a-z]\d:/\?#\[\]@!$&amp;'\(\)\*\+,;=</code> (the reserved and unreserved characters in RFC
        3986, plus the percent character)]</span>. Such a URI is technically not a valid URI. However, it happens in practice
      that users try to turn OS paths into file URIs by simply prepending <code class="code">file:</code> (or <code class="code">file:/</code> for Windows
      forward-slash paths) without thinking about hex-escaping spaces and other special characters. In order to be useful also
      in these circumstances, the function will escape path components, query strings, and fragment identifiers in escapable
      file URIs using <code class="code">fn:encode-for-uri()</code> (see below).</p><p>An OS path is always escapable which means that its path components after slash tokenization will be escaped using
        <code class="code">fn:encode-for-uri()</code>.</p><p>If <code class="code">$basedir</code> is given and if it is identified as a relative OS path or file URI, a dynamic error is
      thrown.</p><p>If no <code class="code">$basedir</code> is given and <code class="code">cwd</code> is unavailable, a dynamic error is thrown for relative
        <code class="code">filepath</code> paths/URIs.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e114"/>Normalization Steps</h3></div></div></div><p>Then the function performs the steps listed below on <code class="code">$filepath</code>.</p><p>It will also normalize <code class="code">$basedir</code> in the same way if <code class="code">$filepath</code> is determined to be relative.</p><p>If <code class="code">$filepath</code> is relative and no <code class="code">$basedir</code> is given, <code class="code">cwd</code> is subjected to the same
      normalization steps. Of course this <code class="code">cwd</code> normalization needs to be done only once if the processor stores the
      result internally.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If <code class="code">$filepath</code> is a relative file URI, <code class="code">^file:</code> will be removed and it will be treated like
          other relative paths.</p></li><li class="listitem"><p>If the operating system path syntax is of type “Windows”, backslashes will be converted to forward
        slashes.</p></li><li class="listitem"><p>If resulting string is determined to be a file URI, its scheme information will be converted to lower
          case (<code class="code">file</code>).</p></li><li class="listitem"><p>The argument will be split into a prefix part and a remainder part. The prefix will hold everything that is
            '<code class="code">file:</code>', slashes, drive letters, and host names, excluding the last slash that follows these
          components. The remainder part then starts with a single slash, or no slash for relative arguments.</p><p>For URI arguments, the remainder part will be further split into a path part, a query part (starting with '?'),
          and a fragment part (starting with '#'), according to RFC 3986, Sect. 3.</p><p>Query or fragment parts stemming from <code class="code">basedir</code> will be disregarded.</p></li><li class="listitem"><p>The resulting path part will be tokenized at <code class="code">/+</code>. Tokens that are empty or that are <code class="code">.</code>
          (current directory) will be removed from the sequences, except for a single leading and a single trailing empty token,
          if present, corresponding to leading and trailing slashes, respectively.</p></li><li class="listitem"><p>Hex escaping: If the argument is escapable, each token in the sequence will be replaced by its
            <code class="code">fn:encode-for-uri()</code> value.</p><p>In the query and fragments parts of escapable URIs, the reserved and unreserved characters such as '=', ';', and
          '&amp;' must be excluded from hex escaping. Apart from these characters, the parts will be hex escaped if and only if
          the URI is escapable. </p><p>OS paths never have query or fragment components, therefore <code class="code">fn:encode-for-uri()</code> will be applied to
          each split-at-slash token.</p></li><li class="listitem"><p>The path part sequences that stem from <code class="code">$filepath</code> and, if present, those that stem from
            <code class="code">$basedir</code> or <code class="code">cwd</code> will be combined so that the <code class="code">$filepath</code> subsequence comes
          last. Duplicate empty tokens at the joint will be contracted into a single one.</p></li><li class="listitem"><p>Parent path contraction: Processing the tokens from left to right, for every group of <code class="code">..</code> tokens the
          same number of preceding tokens (or all preceding tokens if there are less preceding tokens than adjacent parent path
          tokens) will be removed.</p></li><li class="listitem"><p>The path tokens will be re-assembled with each empty token replaced with a slash ('/').</p></li><li class="listitem"><p>In the stored prefix part, lower-case drive letters of Windows OS paths or file URIs will be converted to
          upper-case. </p><p>Host names in the prefix (UNC paths/URIs) will be converted to lower-case.</p><p>Multiple slashes before the host name in UNC file URIs will be reduced to '//' (two slashes).</p><p>A single or more than three slashes in drive letter file URIs will be replaced with exactly three slashes.</p></li><li class="listitem"><p>If the prefix stems from an OS path, <code class="code">file://</code> will be prepended for Unix paths, <code class="code">file:///</code>
          for Windows drive letter paths and <code class="code">file:</code> for Windows UNC paths.</p></li><li class="listitem"><p>Query and fragment parts of the <code class="code">filepath</code> URI argument will be appended, with the '?' and '#'
          separators re-inserted if they were present in the argument.</p></li><li class="listitem"><p>The prefix will be prepended.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="d5e178"/>Errors</h3></div></div></div><p>It is a dynamic error if <code class="code">$filepath</code> is determined to be relative, no <code class="code">$basedir</code> is
    given that can be transformed into an absolute URI and <code class="code">cwd</code> information is unavailable.</p></div></div></body></html>